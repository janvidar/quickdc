/*
 * Copyright (C) 2001-2006 Jan Vidar Krey, janvidar@extatic.org
 * See the file "COPYING" for licensing details.
 */

#include "quickdc.h"
#include "config/iniparser.h"
#include <samurai/timestamp.h>
#include <samurai/io/buffer.h>

#include <map>
#include <string>

#ifdef UNIX
#include <langinfo.h>
#endif // UNIX
namespace QuickDC {

IniParser::IniParser(const std::string& file) : Backend(file) { }

IniParser::~IniParser() { }

void IniParser::writeStart() {
	buffer->clear();
	Samurai::TimeStamp now;
	buffer->append("; QuickDC Preferences 1.0.\n");
#ifdef UNIX
	buffer->append("; Charset: ");
	buffer->append(nl_langinfo(CODESET));
	buffer->append('\n');
#endif // UNIX
	buffer->append("; Written: ");
	buffer->append(now.getTime());
	buffer->append("; Warning: Do NOT edit this file while QuickDC is running.\n");
	buffer->append('\n');
}

void IniParser::writeEnd() {
	buffer->append("; End of file.\n");
}

void IniParser::writeSectionStart(const std::string& group) {
	buffer->append('[');
	buffer->append(group);
	buffer->append("]\n");
}

void IniParser::writeSectionEnd(const std::string&) {
	buffer->append('\n');
}

void IniParser::writeSetting(const std::string& name, const std::string& value) {
	buffer->append(name);
	buffer->append('=');
	buffer->append(value);
	buffer->append('\n');
}

bool IniParser::write() {
	return Backend::write();
}

/**
 * FIXME: Does this work????
 */
std::string remove_whitespace(const std::string& str) {
	size_t start = 0;
	size_t end = 0;
	size_t length = str.length();

	for (start = 0; start < length && (str[start] == ' ' || str[start] == '\t'); start++) { }

	for (end = length-1; end > 0 && (str[end] == ' ' || str[end] == '\t'); end--) { }
	end++;
	
	return str.substr(start, end);

}

/**
 * Read and parse the ini-file.
 *
 *
 * Known bugs:
 * - Does not work with comments at the end of a line
 */
bool IniParser::read() {
	if (!Backend::read()) return false;

	std::string section = "";

	int pos = -1;
	while ((pos = buffer->find('\n')) != -1) {
		if (pos == 0) {
			buffer->remove(1); 
			continue;
		}

		std::string data = remove_whitespace(buffer->pop(pos));
		buffer->remove(pos+1);

		
		
		// Skip comments
		// FIXME: does not parse whitespace before comment
		//        solution; strip whitespace.
		if (data[0] == ';' || data[0] == '#') {
			continue;
		}
			
		// Read section start
		if (data[0] == '[' && data.length() > 2) {
			if (section != "") {
				// Already in section, escape the last one.
				readSectionEnd(section);
			}

			section = remove_whitespace(data.substr(1, data.length()-2));
			readSectionStart(section);
			continue;
		}

			
		size_t split = 0;
		if ((split = data.find('=')) != std::string::npos) {
			std::string name = remove_whitespace(data.substr(0, split));
			std::string val = remove_whitespace(data.substr(split+1));
			readSetting(name, val);

		} else {
			QERR("SYNTAX ERROR: '%s'", data.c_str());
		}
	}
	return true;
}


}
