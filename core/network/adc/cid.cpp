/*
 * Copyright (C) 2001-2007 Jan Vidar Krey, janvidar@extatic.org
 * See the file "COPYING" for licensing details.
 */

#include <stdio.h>
#include <string.h>
#include "quickdc.h"
#include "network/adc/cid.h"
#include <samurai/crypto/digest/tigertree.h>
#include "config/preferences.h"
#include "api/core.h"
#include <samurai/timestamp.h>
#include <samurai/util/base32.h>
#include <unistd.h>
#include <string>

#ifdef WIN32
#include <samurai/io/net/socketglue.h>
#endif

#define HASH 40
static const char* ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";

const char* ADC::SID::toString(sid_t sid_) {
	static char t_sid[5];
	sid_t sid = (sid_ & 0xFFFFF); // 20 bits;
	sid_t A, B, C, D = 0;
	D     = (sid % 32);
	sid   = (sid - D) / 32;
	C     = (sid % 32);
	sid   = (sid - C) / 32;
	B     = (sid % 32);
	sid   = (sid - B) / 32;
	A     = (sid % 32);
	t_sid[0] = ALPHABET[A];
	t_sid[1] = ALPHABET[B];
	t_sid[2] = ALPHABET[C];
	t_sid[3] = ALPHABET[D];
	t_sid[4] = 0;
	return t_sid;
}

sid_t ADC::SID::fromString(const char* sid) {
	if (!sid || strlen(sid) != 4) return 0;
	sid_t nsid = 0;
	sid_t n, x;
	sid_t factors[] = { 32768, 1024, 32, 1};
	for (n = 0; n < 4; n++) {
		for (x = 0; x < strlen(ALPHABET); x++)
			if (sid[n] == ALPHABET[x]) break;
		if (x == 32) return 0;
		nsid += x * factors[n];
	}
	return nsid;
}

bool ADC::CID::verify(const char* cid) {
	if (!cid || strlen(cid) != (HASH-1)) return false;
	for (size_t n = 0; n < strlen(cid); n++) {
		bool hit = false;
		for (size_t x = 0; x < strlen(ALPHABET); x++) {
			if (cid[n] == ALPHABET[x]) hit = true;
		}
		if (!hit) return false;
	}
	return true;
}

bool ADC::CID::verifyCIDandPID(const char* cid, const char* pid) {
	if (!verify(cid) || !verify(pid)) return false;
	
	char x_cid[HASH];
	uint8_t raw_pid[TIGERSIZE];
	
	base32_decode(pid, (unsigned char*) raw_pid, TIGERSIZE);
	
	Samurai::Crypto::Digest::Tiger tiger;
	Samurai::Crypto::Digest::HashValue* value;
	
	tiger.update(raw_pid, TIGERSIZE);
	value = tiger.digest();
	value->getFormattedString(Samurai::Crypto::Digest::HashValue::FormatBase32, x_cid, HASH);
	
	return (strcasecmp(x_cid, cid) == 0);
}

ADC::CID* ADC::global_cid = 0;

ADC::CID* ADC::CID::getInstance() {
	if (!global_cid) {
		global_cid = new CID();
	}
	return global_cid;
}

ADC::CID::CID() : cid(0), pid(0) {
	if (!load()) {
		generate();
		store();
	}
}

ADC::CID::~CID() {
	delete[] cid;
	delete[] pid;
}

// FIXME: Is generated by using the hostname, the current time, the pid, and the build number,
void ADC::CID::generate() {
	QDBG("Generating CID...");
	cid = new char[HASH];
	pid = new char[HASH];

	Samurai::TimeStamp now;
	Samurai::Crypto::Digest::Tiger tiger1;
	Samurai::Crypto::Digest::Tiger tiger2;
	Samurai::Crypto::Digest::HashValue* value;

	char seed[1024] = { 0, };
	gethostname(seed, 16);
	strcat(seed, now.getTime());
	strcat(seed, BUILD);
	strcat(seed, quickdc_itoa((int) getpid(), 10));

	tiger1.update((uint8_t*) seed, strlen(seed));
	value = tiger1.digest();
	value->getFormattedString(Samurai::Crypto::Digest::HashValue::FormatBase32, pid, HASH);
	
	tiger2.update(value->getData(), value->size());
	value = tiger2.digest();
	value->getFormattedString(Samurai::Crypto::Digest::HashValue::FormatBase32, cid, HASH);
	
	QDBG("CID generated: %s (pid=%s)", cid, pid);
}


bool ADC::CID::load() {
	QDBG("Loading CID from configuration file...");
	QuickDC::Preferences* config = QuickDC::Core::getInstance()->config;
	config->setGroup("User");
	
	pid = new char[HASH+1];
	cid = new char[HASH+1];

	char* x_pid = strdup(config->getString("Private ID", ""));
	
	strncpy(pid, x_pid, HASH);
	free(x_pid);

	if (!verify(pid)) {
		delete[] pid; pid = 0;
		delete[] cid; cid = 0;
		return false;
	}

	

	uint8_t pid_decoded[TIGERSIZE] = { 0, };
	base32_decode(pid, (unsigned char*) pid_decoded, TIGERSIZE);
	
	Samurai::Crypto::Digest::Tiger tiger;
	Samurai::Crypto::Digest::HashValue* value;
	tiger.update(pid_decoded, TIGERSIZE);
	value = tiger.digest();
	value->getFormattedString(Samurai::Crypto::Digest::HashValue::FormatBase32, cid, HASH);
	
	QDBG("CID loaded: %s (pid=%s)", cid, pid);
	store();
	return true;
}

bool ADC::CID::store() {
	QDBG("Storing PID: %s", pid);

	if (verifyCIDandPID(cid, pid)) {
		QuickDC::Preferences* config = QuickDC::Core::getInstance()->config;
		config->setGroup("User");
		config->setString("Private ID", pid);
		config->setString("Client ID", cid);
		config->write();
		return true;
	}
	return false;
}

